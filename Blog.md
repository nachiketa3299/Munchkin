# 유니티 씬 동적 비동기 로딩 구현하기

유니티에서 게임 월드를 거대한 하나의 씬으로 구성하면 작업하기도 어렵고, 플레이어 입장에서도 로딩이 오래 걸리는 등 성능상 유리한 점이 별로 없다.


거대한 게임 월드를 작은 단위 씬들로 쪼개서, 플레이어 캐릭터가 이동함에 따라, 캐릭터 근처의 씬들을 동적으로 로드하여 필요한 씬들만 메모리에 올리고 불필요한 씬들은 메모리에서 해제하자.

그러면 플레이어에게 하나의 거대한 게임 월드에서 로딩 없이 돌아다니는 것 같은 착각을 줄 수 있을 것이다. (사실은 아닌데 말이지!!)


암튼, 여러가지 구현 방법이 있겠지만 내가 성공한 방식을 소개하겠다.
요약하면 다음과 같다.

- 씬들의 인접 관계를 정의하는 데이터를 컴파일 타임에 만들어 저장한다. (ScriptableObject 사용)
- 항상 활성화된 상태로 게임 플레이가 종료될 때까지 언로드되지 않는 씬 PersistentGameplay 씬을 정의한다.
- 단위 씬들을 능동적으로 로드/언로드 하는 오브젝트(예를 들어, 캐릭터)*들*에 부착할 스크립트 `SceneLoadTrigger` 작성한다.
- 다수의 `SceneLoadTrigger` 들로부터 씬 로드/언로드 요청을 받고, 취합하여 로드/언로드를 실제로 수행하는 싱글톤 스크립트 `SceneLoadManager` 작성한다.

### 씬들의 인접 관계를 표현하는 데이터 구조 작성

#### 씬 참조 직렬화

씬 애셋들의 관계를 표현하기에 앞서, 씬 애셋의 참조를 직렬화하여, 에디터에서 드래그 & 드롭으로 작업할 수 있다면 편하지 않을까? - `[SerializeField] Scene _scene` 이런게 가능하다면 정말 흥분될 것 같지 않으십니까?

**하지만 놀랍게도 이런 당연하다고 생각되는 기능을 유니티는 제공하지 않는다.** 그 배경에 어떤 기술적 제약과 의도가 있는지 나는 알 도리가 없다.

때문에 기본적으로 씬 애셋은 이름이나 절대 경로, 즉 문자열로 작업해야 하고 이는 굉장히 불편하고 우아하지 못한 방법이다. (참고 - [SceneManager/Unity Documentation](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html))


나는 유니티가 씬 애셋을 내부적으로 어떻게 저장하는지 조사하고 이걸 직렬화 하려면 어떻게 해야 하는지 고민할 정도로는 시간이 남아 돌지는 않으므로, 남이 만들어 둔 걸 쓸 것이다.

검색하면 미리 비슷한 상황에 처했던 사람들이 만들어 둔 코드들이 있으므로 거인의 어깨에 최대한 올라가도록 하자.

참고로 나는 [UnitySceneReference/NibbleByte/Github](https://github.com/NibbleByte/UnitySceneReference)를 사용하였다. (귀찮으면 그냥 문자열로 작업해도 상관은 없다.)

이걸 사용하면,

```csharp
public SceneReference _foo;
[SerializeField] private SceneReference _bar;
```

처럼 표현하여 씬에 대한 참조를 인스펙터에 할당할 수 있다.


#### 씬 그래프 데이터 구조

다수의 씬에 대해, 어떤 씬이 어떤 씬과 인접해있는지 표현하는 데에 가장 적합한 데이터 구조는 당연히 그래프이다.

이 경우 어떤 정점은 씬에 대한 직렬화된 참조이고, 어떤 간선은 부속된 두 씬에 대한 참조가 가리키는 씬들이 서로 인접해 있다는 뜻이다.

당연히 방향성은 없으며, 가중치도 없다. (있을 수도 있나? 허나 상상하기 어렵다.)

예를 들어 씬 A가 씬 B와 인접하고, 씬 B가 씬 C, D와 인접하면 다음처럼 인접 리스트로 그 관계를 정의하고 싶었다.

- 씬 A (인접: B)
- 씬 B (인접: A, C, D)
- 씬 C (인접: B)
- 씬 D (인접: B)

위의 각 항목을 `Node` 라고 정의하고, `Node[]`로 그래프를 표현할 수 있다.

각 노드는 당연히

```csharp
[System.Serializable] public class Node {
	public SceneReference sceneReferences;
	public SceneReference[] adjacentSceneReferences;
}
```

처럼 정의된다.

최종적으로, 각 씬이 서로 얼마만큼 떨어져 있는지에 대한 거리 행렬을 구축할 것이다.

| . | A | B | C | D |
|-|-|-|-|-|
| A | 0 | 1 | 2 | 2 |
| B | 1 | 0 | 1 | 1 |
| C | 2 | 1 | 0 | 2 |
| D | 2 | 1 | 2 | 0 |

이 거리 행렬만 있으면, 거리가 1 이내인 인접한 씬을 로드하라고 설정한 오브젝트 $k$가 씬 C에 입장하면, 씬 B가 로드되어야 하고, 씬 A와 D는 언로드되어야 한다는 요청을 쉽게 보낼 수 있다.

이는 모두 스크립터블 오브젝트를 생성하여, **컴파일 타임에 계산할 내용**이므로 게임 성능과는 상관없다.
당연히 간단한 BFS를 이용하면, 구축한 그래프로 어렵지 않게 위 거리 행렬을 계산해 낼 수 있다.

